<!-- GFM-TOC -->
* [五、类文件结构](#五类文件结构)
  * [Class类文件的结构](#Class类文件的结构)
    * [1. 魔数](#1-魔数)
    * [2. Class文件版本](#2-Class文件版本)
    * [3. 常量池](#3-常量池)
    * [4. 访问标志](#4-访问标志)
    * [5. 当前类索引,父类索引与接口索引集合](#5-当前类索引父类索引与接口索引集合)
    * [6. 字段表集合](#6-字段表集合)
    * [7. 方法表集合](#7-方法表集合)
    * [8. 属性表集合](#8-属性表集合)
  * [字节码指令](#字节码指令)
    * [1. 字节码和数据类型](#1-字节码和数据类型)
    * [2. 加载和存储指令](#2-加载和存储指令)
    * [3. 运算指令](#3-运算指令)
    * [4. 类型转换指令](#4-类型转换指令)
    * [5. 对象创建与访问指令](#5-对象创建与访问指令)
    * [6. 操作数栈管理指令](#6-操作数栈管理指令)
    * [7. 控制转移指令](#7-控制转移指令)
    * [8. 方法调用和返回指令](#8-方法调用和返回指令)
    * [9. 异常处理](#9-异常处理)
    * [10. 同步指令](#10-同步指令)
  * [公有设计和私有实现](#公有设计和私有实现)
* [六、类加载机制](#六类加载机制)
  * [类的生命周期](#类的生命周期)
  * [类加载过程](#类加载过程)
    * [1. 加载](#1-加载)
    * [2. 验证](#2-验证)
    * [3. 准备](#3-准备)
    * [4. 解析](#4-解析)
    * [5. 初始化](#5-初始化)
  * [类初始化时机](#类初始化时机)
    * [1. 主动引用](#1-主动引用)
    * [2. 被动引用](#2-被动引用)
  * [类与类加载器](#类与类加载器)
  * [类加载器分类](#类加载器分类)
  * [双亲委派模型](#双亲委派模型)
    * [1. 工作过程](#1-工作过程)
    * [2. 好处](#2-好处)
    * [3. 实现](#3-实现)
    * [4. “破坏”](#4-破坏)
  * [自定义类加载器实现](#自定义类加载器实现)
* [七、字节码执行引擎](#七字节码执行引擎)
  * [运行时栈帧结构](#运行时栈帧结构)
    * [1. 局部变量表](#1-局部变量表)
    * [2. 操作数栈](#2-操作数栈)
    * [3. 动态连接](#3-动态连接)
    * [4. 方法返回地址](#4-方法返回地址)
  * [方法调用](#方法调用)
    * [1. 解析](#1-解析)
    * [2. 分派](#2-分派)
    * [3. 动态类型语言支持](#3-动态类型语言支持)
  * [基于栈的字节码解释执行引擎](#基于栈的字节码解释执行引擎)
    * [1. 解释执行](#1-解释执行)
    * [2. 指令集](#2-指令集)
* [八、程序编译与代码优化](#八程序编译与代码优化)
  * [早期(编译期)优化](#早期编译期优化)
    * [1. javac编译器](#1-javac编译器)
    * [2. Java语法糖](#2-Java语法糖)
  * [晚期(运行期)优化](#晚期运行期优化)
    * [1. 解释器与编译器](#1-解释器与编译器)
    * [2. 编译对象与触发条件](#2-编译对象与触发条件)
    * [3. 编译过程](#3-编译过程)
    * [4. 编译优化技术](#4-编译优化技术)
    * [5. Java与C/C++的编译器对比](#5-Java与CC的编译器对比)
* [参考资料](#参考资料)
* [微信公众号](#微信公众号)

<!-- GFM-TOC -->


本文大部分内容参考  **周志明《深入理解 Java 虚拟机》** ，想要深入学习的话请看原书。

# JDK监控



1、jps：查看本机java进程信息。

2、jstack：打印线程的栈信息，制作线程dump文件。

3、jmap：打印内存映射，制作堆dump文件

4、jstat：性能监控工具

5、jhat：内存分析工具

6、jconsole：简易的可视化控制台

7、jvisualvm：功能强大的控制台
